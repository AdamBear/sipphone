
/****************************************************************************
**
** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (qt-info@nokia.com)
**
** This file is part of the QtCore module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL$
** Commercial Usage
** Licensees holding valid Qt Commercial licenses may use this file in
** accordance with the Qt Commercial License Agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and Nokia.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Nokia gives you certain additional
** rights.  These rights are described in the Nokia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3.0 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU General Public License version 3.0 requirements will be
** met: http://www.gnu.org/copyleft/gpl.html.
**
** If you have questions regarding the use of this file, please contact
** Nokia at qt-info@nokia.com.
** $QT_END_LICENSE$
**
****************************************************************************/

/* This file is autogenerated from the Unicode 5.0 database. Do not edit */

//
//  W A R N I N G
//  -------------
//
// This file is not part of the Qt API.  It exists for the convenience
// of internal files.  This header file may change from version to version
// without notice, or even be removed.
//
// We mean it.
//

#ifndef QUNICODETABLES_P_H
#define QUNICODETABLES_P_H

#include "lang_config.h"


#ifdef IF_FEATURE_ARABIC


/*
 @Edit by liany 2015-5-18@
1. 阿拉伯语连写使用Qt代码，会引入完整Unicode映射表，导致编译体积增大约60K
2. 添加 ARABIC_SIZE_OPT 宏用于控制是否使用完整的unicode映射表
3. ARABIC_SIZE_OPT定义之后使用自定义的两个函数（函数名如下所示）替代Qt提供的接口，
4. 自定义函数只包含阿拉伯字符（和常用字符，如常用符号、拉丁字符等，不包含其它国家语言），编译之后体积减少约55K左右


5. ARABIC_DEBUG 用于提取对应的字符映射关系。

函数名（HB_GetUnicodeCharCategory、 HB_GetMirroredChar）
ARABIC_DEBUG 宏默认不能开启，只作为本地调试使用。

ARABIC_SIZE_OPT 默认开启 ARABIC_DEBUG 默认关闭
*/


#include "lang_config.h"


typedef unsigned short ushort;
typedef unsigned int   uint;

namespace QUnicodeTables
{

struct Properties
{
    ushort category : 8;
    ushort line_break_class : 8;
    ushort direction : 8;
    ushort combiningClass : 8;
    ushort joining : 2;
    signed short digitValue : 6; /* 5 needed */
    ushort unicodeVersion : 4;
    ushort lowerCaseSpecial : 1;
    ushort upperCaseSpecial : 1;
    ushort titleCaseSpecial : 1;
    ushort caseFoldSpecial : 1; /* currently unused */
    signed short mirrorDiff : 16;
    signed short lowerCaseDiff : 16;
    signed short upperCaseDiff : 16;
    signed short titleCaseDiff : 16;
    signed short caseFoldDiff : 16;
    ushort graphemeBreak : 8;
    ushort wordBreak : 8;
    ushort sentenceBreak : 8;
};

typedef enum
{
    HB_NoCategory,

    HB_Mark_NonSpacing,          /*   Mn */
    HB_Mark_SpacingCombining,    /*   Mc */
    HB_Mark_Enclosing,           /*   Me */

    HB_Number_DecimalDigit,      /*   Nd */
    HB_Number_Letter,            /*   Nl */
    HB_Number_Other,             /*   No */

    HB_Separator_Space,          /*   Zs */
    HB_Separator_Line,           /*   Zl */
    HB_Separator_Paragraph,      /*   Zp */

    HB_Other_Control,            /*   Cc */
    HB_Other_Format,             /*   Cf */
    HB_Other_Surrogate,          /*   Cs */
    HB_Other_PrivateUse,         /*   Co */
    HB_Other_NotAssigned,        /*   Cn */

    HB_Letter_Uppercase,         /*   Lu */
    HB_Letter_Lowercase,         /*   Ll */
    HB_Letter_Titlecase,         /*   Lt */
    HB_Letter_Modifier,          /*   Lm */
    HB_Letter_Other,             /*   Lo */

    HB_Punctuation_Connector,    /*   Pc */
    HB_Punctuation_Dash,         /*   Pd */
    HB_Punctuation_Open,         /*   Ps */
    HB_Punctuation_Close,        /*   Pe */
    HB_Punctuation_InitialQuote, /*   Pi */
    HB_Punctuation_FinalQuote,   /*   Pf */
    HB_Punctuation_Other,        /*   Po */

    HB_Symbol_Math,              /*   Sm */
    HB_Symbol_Currency,          /*   Sc */
    HB_Symbol_Modifier,          /*   Sk */
    HB_Symbol_Other              /*   So */
} HB_CharCategory;

typedef enum
{
    HB_NoJustification = 0,  /* Justification can't be applied after this glyph */
    HB_Arabic_Space   = 1,   /* This glyph represents a space inside arabic text */
    HB_Character      = 2,   /* Inter-character justification point follows this glyph */
    HB_Space          = 4,   /* This glyph represents a blank outside an Arabic run */
    HB_Arabic_Normal  = 7,   /* Normal Middle-Of-Word glyph that connects to the right (begin) */
    HB_Arabic_Waw     = 8,   /* Next character is final form of Waw/Ain/Qaf/Fa */
    HB_Arabic_BaRa    = 9,   /* Next two chars are Ba + Ra/Ya/AlefMaksura */
    HB_Arabic_Alef    = 10,  /* Next character is final form of Alef/Tah/Lam/Kaf/Gaf */
    HB_Arabic_HaaDal  = 11,  /* Next character is final form of Haa/Dal/Taa Marbutah */
    HB_Arabic_Seen    = 12,  /* Initial or Medial form Of Seen/Sad */
    HB_Arabic_Kashida = 13   /* Kashida(U+640) in middle of word */
} HB_JustificationClass;
};

namespace QUnicodeTables
{
#ifndef ARABIC_SIZE_OPT
const Properties * properties(uint ucs4);
const Properties * properties(ushort ucs2);

const unsigned char HB_GetUnicodeCharCategory(ushort ucs2);
const ushort HB_GetMirroredChar(ushort ucs2);
#endif

const unsigned char HB_GetUnicodeCharCategory(uint ucs4);
const ushort HB_GetMirroredChar(uint ucs4);
}

#endif

#endif
